#include <stdio.h>
void Swap(int a, int b);
void Swap_Address(int* a, int* b);
void ArraySwap(int* ptr);

int main_pointer(void) {
	// 포인터

	/*
	// 가정 : 애들이 살고 있는 집에는 암호가 있음
	// 철수 : 101호, 영희 : 201호, 민수 : 301호 
	
	int 철수 = 1;
	int 영희 = 2;
	int 민수 = 3;

	// 실제 변수는 그 값을 담고 있는게 아니라 값을 가지고 있는 메모리의 주솟값을 가지고 있음
	// 주솟값을 보려면 변수 앞에 &를 붙이면 됨
	printf("철수네 주소 : %d, 암호 : %d\n", &철수, 철수);
	//printf("영희네 주소 : %d, 암호 : %d\n", &영희, 영희);
	//printf("민수네 주소 : %d, 암호 : %d\n", &민수, 민수);

	// 미션맨 
	// 첫 번째 미션 : 애들 집에 암호 확인하기
	int *미션맨 = &철수; // 앞에 *붙여서 포인터 변수 선언
	
    printf("미션맨이 방문한 곳 주소 : %d, 방문한 곳 암호 : %d\n", 미션맨, *미션맨);

	// 2번째 미션 암호에 곱하기 3 하기
	// 어떤 변수의 주솟값을 가지는 포인터는 그 주소가 가르키는 변수의 값을 직접 바꿀 수 있음
	*미션맨 *= 3; // 철수 *= 3; 과 같음
	printf("미션맨이 미션 수행한 집 주소 : %d, 미션 성공한 암호 : %d\n", 미션맨, *미션맨);
	printf("미션 수행한 철수 집 암호 : %d\n", 철수); // 3

	// 포인터는 *안붙이면 그냥 주소값
	// *붙이면 주소로 찾아가서 거기에 있는 변수값이 되고 그 값을 바꾸면 변수값도 바뀜

	// 스파이 
	// 미션맨이 바꾼 암호에서 30을 뺌
	// 값을 대입하는 건 int 스파이 = 미션맨; 하는거랑 똑같음
	// 단지 포인터로 선언하면 *스파이 형식으로 주소값이 가리키는 변수에 접근 가능
	int *스파이 = 미션맨; 
	*스파이 -= 30;
	printf("\n미션맨이 암호를 바꾼 주소 : %d, 바뀐 암호 :  %d\n", 스파이, *스파이);
	printf("스파이가 조작한 철수 집 암호 : %d\n", 철수); // 3

	// 포인터 변수 역시 변수이기 때문에 따로 주소가 할당됨
	printf("미션맨 주소 : %d\n", &미션맨);
	printf("스파이 주소 : %d\n", &스파이);
	*/



	// 배열과 포인터의 관계
	/*
	int arr[3] = { 5, 10, 15 };
	int* ptr = arr;

	for (int i = 0; i < 3; i++) {
		printf("배열의 값 : %d\n", arr[i]);
	}

	for (int i = 0; i < 3; i++) {
		printf("포인터 배열의 값 : %d\n", ptr[i]);
	}

	// arr에서도 값이 바뀜 (배열에서만 됨 일반 int 변수에서는 안됨)
	ptr[0] = 100;
	ptr[1] = 200;
	ptr[2] = 300;

	for (int i = 0; i < 3; i++) {
		//printf("배열의 값 : %d\n", arr[i]);
		printf("배열의 값 : %d\n", *(arr + i));
	}

	for (int i = 0; i < 3; i++) {
		//printf("포인터 배열의 값 : %d\n", ptr[i]);
		printf("포인터 배열의 값 : %d\n", *(ptr + i));
	}

	// *(arr + i) == arr[i] 즉, 똑같은 표현
	// arr 자체의 값은 arr 배열의 첫번째 값의 주소와 동일 즉 arr == &arr[0]
	printf("arr 자체의 값 : %d\n", arr);
	printf("arr[0] 의 주소 : %d\n", &arr[0]);
	printf("ptr 자체의 값 : %d\n", ptr);

	// 배열은 자신의 첫번째 값의 주소와 동일한 값을 가짐
	// 일반 int 변수를 포인터 변수에 대입하면 변수의 값을 대입
	// 하지만 배열을 대입하면 배열의 값(배열의 첫번째 인덱스 값 주소) 자체를 대입함
	// 때문에 자료형이 배열이 아니여도 대입이 가능하고(int형에 배열 값 대입 가능) 
	// * 안붙인 포인터 변수의 값을 바꾸면 대입한 배열에 영향을 주는 거임 (어차피 배열 값은 같으니까 즉 같은 배열)

	printf("arr 자체의 값이 가지는 주소의 실제 값 : %d\n", *arr); // *(arr + 0)  과 같음
	printf("arr[0] 의 실제 값 : %d\n", *&arr[0]);
	// &는 변수의 주소, *은 그 주소의 값이기 때문에 &*는 아무것도 없는 것과 같음
	*/


	// SWAP
	int a = 10;
	int b = 20;
	printf("a 주소 : %d, b 주소 : %d\n", &a, &b);
	printf("Swap 함수 전 => a : %d, b : %d\n", a, b);
	Swap(a, b);
	printf("Swap 함수 후 => a : %d, b : %d\n", a, b);

	Swap_Address(&a, &b);
	printf("Swap_Address 함수 후 => a : %d, b : %d\n", a, b);

	// 값에 의한 복사 (Copy by Value) : 값만 복사한다는 의미

	// 이걸로 scanf_s 에서 변수 앞에 &를 붙인 이유를 알 수 있는데
	// 이유는 함수 내부에서 변수의 값을 바꾸려면 변수의 주소에 접근해야 하기 때문에

	int arr_2[3] = { 1, 4, 65 };
	ArraySwap(arr_2); // 배열은 지 값이 그냥 주소임
	//ArraySwap(&arr_2[0]); // 위에거랑 똑같음
	for (int i = 0; i < 3; i++) {
		printf("%d\n", arr_2[i]);
	}
}

void Swap(int a, int b) { // 인자값으로 넘기는 것은 값에 의한 복사 즉 주소가 다름
	int temp = a; // 바로 a를 b로 바꾸면 b를 a로 못 바꾸니까 임시로 a의 값을 가질 변수 선언
	
	a = b;
	b = temp;
	printf("함수 내 a 주소 : %d, 함수 내 b 주소 : %d\n", &a, &b);
	printf("Swap 함수 중 => a : %d, b : %d\n", a, b);
}

// 함수 내에서 다른 범위의 블록에 있는 값을 참조 없이 인자값만 받아서 바꿈(와 개쩐다!! 포인터 짱짱맨)
void Swap_Address(int* a, int* b) { // 인자값으로 넘기는 것은 값에 의한 복사 즉 주소가 다름
	int temp = *a; // 바로 a를 b로 바꾸면 b를 a로 못 바꾸니까 임시로 a의 값을 가질 변수 선언

	*a = *b;
	*b = temp;
}

void ArraySwap(int* ptr) {
	ptr[2] = 12451;
}